import {useDispatch, useSelector} from "react-redux";
import {selectChannelName, setConnected, setTyping, updateOnline} from "../../redux/chatSlice";
import {wpmToMorseTimes} from "../../redux/userSlice";
import * as React from "react";
import {pusherClient} from "../../utils/apiResolver";
import getDialect from '../../utils/dialects'

export function AppLogic({chatDomNode}) {
    const dispatch = useDispatch()
    let loading = useSelector(state => state.api.loading)
    let csrf = useSelector(state => state.api.csrf)
    let callsign = useSelector(state => state.user.callsign)
    let app = useSelector(state => state.app)
    let channel = useSelector(state => state.chat.channel)
    let channelName = useSelector(selectChannelName)
    const pusher = React.useRef(null)
    const pusherChannel = React.useRef(null)

    let dialectName = useSelector(state => state.user.settings.dialect)
    let dialect = getDialect(dialectName)

    /**
     * recursive typer loop. It's job is to type a received message into the chat,
     * with the same timings of the sender
     * 
     * @param {DOMElement} morse - the html element where we'll display the raw morse code
     * @param {DOMElement} morseLetters - the html element where we'll display the translated morse
     * @param {number[]} message - an array of integers, representing the received message
     * @param {Object} times - the morse times object, as generated by wpmToMorseTimes
     * @param {number} i - the current position of the typer while iterating the message array
     * @param {*} letter - the letter the typer is currently decoding
     * @param {*} morseOut - the text content of the morse domElement
     * @param {*} morseLettersOut - the text content of the morseLetters domElement
     * TODO: remove morseOut and morseLettersOut, use element.insertAdjacentText('beforeend', text)
     */
    function typer(morse, morseLetters, message, times, i=0, letter="", morseOut="", morseLettersOut=""){
        let t = message[i]
        //released after t millis
        if(i%2 == 0){
            if(t < times.dash){
                letter += "."
            }else{
                letter += "_"
            }
        }
        //pressed after t millis
        else{
            if(t > times.wordGap){
                morseOut += letter + "   "
                morseLettersOut += translateToReadable(letter) + "  "
                letter = ""
            }
            else if(t > times.letterGap){
                morseOut += letter + " "
                morseLettersOut += translateToReadable(letter)
                letter = ""
            }
        }
        morse.innerText = morseOut + letter
        if(i < message.length-1){
            morseLetters.innerText = morseLettersOut + " " + letter
            setTimeout(typer, message[i], morse, morseLetters, message, times, i+1, letter, morseOut, morseLettersOut)
        }
        else{
            //translate what is left
            morseLetters.innerText = morseLettersOut + translateToReadable(letter)
        }
    }
    function translateToReadable(letter){
        letter = letter.replaceAll("_", "-")
        if(dialect.table.hasOwnProperty(letter))
            return dialect.table[letter];
        return " " + letter + " ";
    }

    /**
     * Called when a message is received. Initialize the typer loop
     * 
     * @param {*} e 
     */
    function handleMessage(e) {
        let chat = chatDomNode.current
        let message = document.createElement("p")
        let label = document.createElement("span") 
        let morse = document.createElement("span")
        let text = document.createElement("span")
        message.appendChild(label)
        message.appendChild(morse)
        message.appendChild(text)
        label.innerText = e.callsign
        let times = wpmToMorseTimes(e.wpm)
        typer(morse, text, e.message, times)
        chat.insertAdjacentElement("beforeend", message)
        //scroll down if the user is not reading old messages
        let margin = 60 //arbitrary value
        let scrollDown = (chat.scrollTop > (chat.scrollHeight - chat.clientHeight - margin));
        if(scrollDown){
            chat.scrollTop = chat.scrollHeight
        }
    }

    //sync the selected channel with the query param
    //look mom! no react router
    React.useEffect(() => {
        let searchParams = new URLSearchParams(window.location.search);
        searchParams.set("channel", channelName);
        let newPath = window.location.pathname + '?' + searchParams.toString();
        history.pushState(null, '', newPath);
    }, [channel])

    /**
     * Pusher client initialization effect
     *
     * TODO: unbind all callbacks and check for mem leaks
     */
    React.useEffect(() => {
        if (loading == false) {
            if (pusher.current === null) {
                //initialize the pusher client
                pusher.current = pusherClient(
                    csrf,
                    app.pusher_key,
                    app.pusher_host,
                    app.pusher_port,
                    app.pusher_cluster
                )
                //update pusher server connection status
                //this is not related to the channel subscription
                pusher.current.connection.bind('state_change', (states) => {
                    dispatch(setConnected(states.current))
                })
            } else {
                console.warn("reinitializing pusher ref")
            }
        }
    }, [loading]);


    /**
     * channel connection effect
     * - runs on every change of the selected channel, or of the user callsign
     * - unsubscribes from the previous channel
     * - connects to the new channel, updating the bindings
     */
    React.useEffect(() => {
        if (pusher.current) {
            console.log(">> effect: subscribing to channel " + channel)
            pusherChannel.current = pusher.current.subscribe(channel)
            dispatch(setConnected('connecting'))

            pusherChannel.current.bind('pusher:subscription_succeeded', e => {
                dispatch(setConnected('connected'))
                dispatch(updateOnline(JSON.parse(JSON.stringify(e))))
                if (chatDomNode.current)
                    chatDomNode.current.innerHTML = ""
            })

            pusherChannel.current.bind('pusher:subscription_error', e => {
                if (e.error === "pusher_auth_denied login_needed")
                    dispatch(setConnected('connection denied'))
                else
                    dispatch(setConnected('connection failed'))
                dispatch(updateOnline({members: {}, myID: null}))
            })

            pusherChannel.current.bind('pusher:member_added', e => {
                dispatch(updateOnline(JSON.parse(JSON.stringify(
                    pusherChannel.current.members
                ))))
            })

            pusherChannel.current.bind('pusher:member_removed', e => {
                dispatch(updateOnline(JSON.parse(JSON.stringify(
                    pusherChannel.current.members
                ))))
            })

            pusherChannel.current.bind('message', e => {
                handleMessage(e)
                dispatch(setTyping({
                    user: e.id,
                    typing: false
                }))
            })
            pusherChannel.current.bind('typing', e => {
                console.log(e)
                dispatch(setTyping({
                    user: e.id,
                    typing: true
                }))
            })
            return () => {
                console.log(">> effect: unsubscribing from channel " + channel);
                pusherChannel.current.unbind()
                pusher.current.unsubscribe(channel)
            }
        } else {
            console.log(">> effect: subscribing to channel [NO PUSHER YET] " + channel)
        }
    }, [channel, callsign])


    return null
}