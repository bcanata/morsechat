import {useDispatch, useSelector} from "react-redux";
import {selectChannelName, setConnected, setTyping, updateOnline} from "../redux/chatSlice";
import {wpmToMorseTimes} from "../redux/userSlice";
import * as React from "react";
import {pusherClient} from "../utils/apiResolver";
import getDialect from '../utils/dialects'

import ctx from '../utils/soundCtx'

export function AppLogic({chatDomNode}) {
    const dispatch = useDispatch()
    let loading = useSelector(state => state.api.loading)
    let csrf = useSelector(state => state.api.csrf)
    let callsign = useSelector(state => state.user.callsign)
    let app = useSelector(state => state.app)
    let channel = useSelector(state => state.chat.channel)
    let channelName = useSelector(selectChannelName)
    const pusher = React.useRef(null)
    const pusherChannel = React.useRef(null)

    let dialectName = useSelector(state => state.user.settings.dialect)
    let dialect = getDialect(dialectName)
    //audio related selectors
    let volume = useSelector(state => state.user.settings.volume_receiver)
    let onlineUsers = useSelector(state => state.chat.onlineUsers)
    //get a reference to volume so that code in callbacks will have access to
    //it without outdated bindings
    //https://stackoverflow.com/a/60643670
    let volumeRef = React.useRef()
    volumeRef.current = volume
    let onlineUsersRef = React.useRef()
    onlineUsersRef.current = onlineUsers

    /**
     * recursive typer loop. Its job is to type a received message into the chat,
     * with the same timings of the sender
     * note: this should be refactored into something cleaner, maybe a generator func
     * 
     * @param {DOMElement} morse - the html element where we'll display the raw morse code
     * @param {DOMElement} morseLetters - the html element where we'll display the translated morse
     * @param {number[]} message - an array of integers, representing the received message
     * @param {Object} times - the morse times object, as generated by wpmToMorseTimes
     * @param {ReceiverSound} sound - the sound manager associated to the user
     * @param {number} i - the current position of the typer while iterating the message array
     * @param {*} letter - the letter the typer is currently decoding
     * @param {*} morseOut - the text content of the morse domElement
     * @param {*} morseLettersOut - the text content of the morseLetters domElement
     * TODO: remove morseOut and morseLettersOut, use element.insertAdjacentText('beforeend', text)
     */
    function typer(morse, morseLetters, message, times, sound, i=0, letter="", morseOut="", morseLettersOut=""){
        let t = message[i]

        //released after t millis
        if(i%2 == 0){
            sound.on()
            if(t < times.dash){
                letter += "."
            }else{
                letter += "_"
            }
        }
        //pressed after t millis
        else{
            sound.off()
            if(t > times.wordGap){
                morseOut += letter + "   "
                morseLettersOut += translateToReadable(letter) + "  "
                letter = ""
            }
            else if(t > times.letterGap){
                morseOut += letter + " "
                morseLettersOut += translateToReadable(letter)
                letter = ""
            }
        }
        morse.innerText = morseOut + letter
        if(i < message.length){
            morseLetters.innerText = morseLettersOut + " " + letter
            setTimeout(typer, message[i], morse, morseLetters, message, times, sound, i+1, letter, morseOut, morseLettersOut)
        }
        else{
            //translate what is left
            morseLetters.innerText = morseLettersOut + translateToReadable(letter)
            //stop and remove the audio gain node
            sound.disconnect()
        }
    }
    function translateToReadable(letter){
        letter = letter.replaceAll("_", "-")
        if(dialect.table.hasOwnProperty(letter))
            return dialect.table[letter];
        return " " + letter + " ";
    }

    /**
     * scroll to the bottom of the chat, but only if the user is not
     * reading old messages
     */
    function scrollDown(){
        let chat = chatDomNode.current
        let margin = 60 //arbitrary value
        let scrollDown = (chat.scrollTop > (chat.scrollHeight - chat.clientHeight - margin));
        if(scrollDown){
            chat.scrollTop = chat.scrollHeight
        }
    }

    /**
     * Called when a message is received. Initialize the typer loop
     * 
     */
    function handleMessage(e) {
        //initialize DOM nodes
        let chat = chatDomNode.current
        let message = document.createElement("p")
        let label = document.createElement("span") 
        let morse = document.createElement("span")
        let text = document.createElement("span")
        message.appendChild(label)
        message.appendChild(morse)
        message.appendChild(text)
        label.innerText = e.callsign
        //initialize wpm times
        let times = wpmToMorseTimes(e.wpm)
        //initialize the sound class for this specific user
        //todo: there should be a sound object associated to every online user,
        //it's more efficient than creating an obj on every message
        let sound = new ReceiverSound(e.id, volumeRef, onlineUsersRef)
        //start the typer recursive function
        typer(morse, text, e.message, times, sound)
        chat.insertAdjacentElement("beforeend", message)
        //scroll down if the user is not reading old messages
        scrollDown()
    }


    //TODO: move to dedicated file un utils, with dedicated audioctx import
    /**
     * Manages the receiver sound for a specific userId
     * 
     * depends on the global audio context: it should exist as variable named ctx
     */
    class ReceiverSound{
        /**
         * The default behaviour for the sound volume of messages from
         * disconnected user
         */
        playSoundForDisconnectedUsers = false

        /**
         * 
         * @param {String} uid - the user id of the message we are reproducing
         * @param {*} volumeRef - a React.useRef() pointing to the settings.volume_receiver useSelector value
         *                        This class is expected to be used from within callbacks,
         *                        where a simple reference to useSelector would remain outdated
         */
        constructor(uid, volumeRef, onlineUsers){
            this.uid = uid
            this.volumeRef = volumeRef
            this.onlineUsers = onlineUsers
            this.baseVolume = 0.0000001
            this.lastKnownPermision = this.playSoundForDisconnectedUsers

            let note = 880 //TODO: generate from RND seeded with user callsign
            let o = ctx.createOscillator()
            o.frequency.value = note
            o.type = "triangle"
            let g = ctx.createGain()
            o.connect(g)
            g.connect(ctx.destination)
            g.gain.setValueAtTime(this.baseVolume, ctx.currentTime)
            o.start()
            this.g = g
        }

        /**
         * Start the sound
         */
        on(){
            //if sound is disabled for this specific user or message
            if(!this.#getSoundPermissions())
                return
            let volume = this.volumeRef.current
            if (volume < 0) volume = 0
            if (volume > 100) volume = 100
            const highVolume = (volume + this.baseVolume) / 100
            this.g.gain.setValueAtTime(highVolume, ctx.currentTime)
        }

        /**
         * Stops the sound
         */
        off(){
            this.g.gain.setValueAtTime(this.baseVolume, ctx.currentTime)
        }

        /**
         * disconnect this specific sound instance from the audiocontext,
         * allowing garbage collection
         * @todo - test
         */
        disconnect(){
            this.g.disconnect()
        }

        #getSoundPermissions(){
            let online = this.onlineUsers.current
            //if the user is disconnected we cannot access its allowSound property,
            //so we use the last known permission, or the default value
            if(!online.hasOwnProperty(this.uid))
                return this.lastKnownPermision
            //access user allowSound
            let permission = online[this.uid].allowSound
            this.lastKnownPermision = permission
            return permission
        }
    }

    function systemMessage(msg){
        let chat = chatDomNode.current
        let message = document.createElement("p")
        message.innerText = msg
        chat.insertAdjacentElement("beforeend", message)
        //scroll down if the user is not reading old messages
        scrollDown()
    }

    //sync the selected channel with the query param
    //look mom! no react router
    React.useEffect(() => {
        let searchParams = new URLSearchParams(window.location.search);
        searchParams.set("channel", channelName);
        let newPath = window.location.pathname + '?' + searchParams.toString();
        history.pushState(null, '', newPath);
    }, [channel])

    /**
     * Pusher client initialization effect
     *
     * TODO: unbind all callbacks and check for mem leaks
     */
    React.useEffect(() => {
        if (loading == false) {
            if (pusher.current === null) {
                //initialize the pusher client
                pusher.current = pusherClient(
                    csrf,
                    app.pusher_key,
                    app.pusher_host,
                    app.pusher_port,
                    app.pusher_cluster
                )
                //update pusher server connection status
                //this is not related to the channel subscription
                pusher.current.connection.bind('state_change', (states) => {
                    dispatch(setConnected(states.current))
                })
            } else {
                console.warn("reinitializing pusher ref")
            }
        }
    }, [loading]);

    /**
     * channel connection effect
     * - runs on every change of the selected channel, or of the user callsign
     * - unsubscribes from the previous channel
     * - connects to the new channel, updating the bindings
     */
    React.useEffect(() => {
        if (pusher.current) {
            console.log(">> effect: subscribing to channel " + channel)
            pusherChannel.current = pusher.current.subscribe(channel)
            dispatch(setConnected('connecting'))

            pusherChannel.current.bind('pusher:subscription_succeeded', e => {
                dispatch(setConnected('connected'))
                dispatch(updateOnline(JSON.parse(JSON.stringify(e))))
                //clear the chat (TODO: this hshould not happen after a simple disconnect)
                //idea: clear the screen only when the channel is changed from the selector,
                //maybe adding a connecting.. message
                if (chatDomNode.current)
                    chatDomNode.current.innerHTML = ""
                //show successfully connected message
                systemMessage("connected to " + channelName + " with callsign: " + callsign)
            })

            pusherChannel.current.bind('pusher:subscription_error', e => {
                if (e.error === "pusher_auth_denied login_needed")
                    dispatch(setConnected('connection denied'))
                else
                    dispatch(setConnected('connection failed'))
                dispatch(updateOnline({members: {}, myID: null}))
            })

            pusherChannel.current.bind('pusher:member_added', e => {
                dispatch(updateOnline(JSON.parse(JSON.stringify(
                    pusherChannel.current.members
                ))))
            })

            pusherChannel.current.bind('pusher:member_removed', e => {
                dispatch(updateOnline(JSON.parse(JSON.stringify(
                    pusherChannel.current.members
                ))))
            })

            pusherChannel.current.bind('message', e => {
                handleMessage(e)
                dispatch(setTyping({
                    user: e.id,
                    typing: false
                }))
            })
            pusherChannel.current.bind('typing', e => {
                dispatch(setTyping({
                    user: e.id,
                    typing: true
                }))
            })
            return () => {
                console.log(">> effect: unsubscribing from channel " + channel);
                pusherChannel.current.unbind()
                pusher.current.unsubscribe(channel)
            }
        } else {
            console.log(">> effect: subscribing to channel [NO PUSHER YET] " + channel)
        }
    }, [channel, callsign])


    return null
}